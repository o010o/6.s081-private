Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

For normal function call, a0-7 store the function arguments.And we passed more argument by stack if need.
For printf, we have three arguments in call.c:main,a0 store the first, and a1 stores the second, a2 stores the third.

Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

we passed the f(8) + 1 as second argument to the printf.At call.asm:26, f(8) had been calculated, and had added one, so we passed 12=f(8)+1
as the second argument.So f() had been inlined.

At call.asm:32 g() had been inlined either.

At what address is the function printf located?

0x628(call.asm:1076)

What value is in the register ra just after the jalr to printf in main?

0x38. 
JAL stores the address of the instruction following the jump (pc+4) into register rd. The pc of jalr is 0x34, when jalr called, it stored 0x38 = 0x34 + 4 into register rd.

Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

It seems that the risc-v is little-endian.

57616=0xE110

0x64='d'
0x6c='l'
0x72='r'

so output is:
"He110 World"


In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);
      
output:
"x=3 y="

the value after y= should the third argument of printf, but we do not pass a third argument which stored in register a2.
so the value after "y=" is the value in register a2.

